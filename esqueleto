#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

// Estrutura para representar o grafo das cidades e distâncias
typedef struct {
    int max_cidades;    // Número máximo de cidades definido pelo usuário
    int num_cidades;    // Número atual de cidades cadastradas
    char **nomes;       // Nomes das cidades (alocação dinâmica)
    int **distancias;   // Matriz de distâncias (alocação dinâmica)
} GrafoTSP;

// Função auxiliar para limpar o buffer de entrada
void limparBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// Função para ler um número inteiro com validação
int lerInteiro(const char *prompt, int min, int max) {
    char input[50];
    int valor;
    bool valido = false;
    
    while (!valido) {
        printf("%s", prompt);
        fgets(input, sizeof(input), stdin);
        
        // Verifica se a entrada é um número inteiro válido
        if (sscanf(input, "%d", &valor) == 1) {
            if (valor >= min && valor <= max) {
                valido = true;
            } else {
                printf("Valor deve estar entre %d e %d. Tente novamente.\n", min, max);
            }
        } else {
            printf("Entrada invalida. Digite um numero inteiro. Tente novamente.\n");
        }
    }
    
    return valor;
}

// Função para ler um nome de cidade válido
void lerNomeCidade(char *nome) {
    bool valido = false;
    
    while (!valido) {
        printf("Digite o nome da cidade: ");
        fgets(nome, 50, stdin);
        nome[strcspn(nome, "\n")] = '\0'; // Remove o \n do final
        
        // Verifica se o nome não está vazio
        if (strlen(nome) > 0) {
            valido = true;
        } else {
            printf("Nome da cidade nao pode ser vazio. Tente novamente.\n");
        }
    }
}

// Função para inicializar o grafo
void inicializarGrafo(GrafoTSP *grafo, int max) {
    grafo->max_cidades = max;
    grafo->num_cidades = 0;
    
    grafo->nomes = (char **)malloc(max * sizeof(char *));
    for (int i = 0; i < max; i++) {
        grafo->nomes[i] = (char *)malloc(50 * sizeof(char));
        strcpy(grafo->nomes[i], "");
    }
    
    grafo->distancias = (int **)malloc(max * sizeof(int *));
    for (int i = 0; i < max; i++) {
        grafo->distancias[i] = (int *)malloc(max * sizeof(int));
        for (int j = 0; j < max; j++) {
            grafo->distancias[i][j] = (i == j) ? 0 : -1;
        }
    }
}

// Função para liberar memória
void liberarGrafo(GrafoTSP *grafo) {
    for (int i = 0; i < grafo->max_cidades; i++) {
        free(grafo->nomes[i]);
    }
    free(grafo->nomes);
    
    for (int i = 0; i < grafo->max_cidades; i++) {
        free(grafo->distancias[i]);
    }
    free(grafo->distancias);
}

// Função para adicionar cidade com validação
void adicionarCidade(GrafoTSP *grafo) {
    if (grafo->num_cidades >= grafo->max_cidades) {
        printf("Limite maximo de cidades atingido (%d)!\n", grafo->max_cidades);
        return;
    }
    
    lerNomeCidade(grafo->nomes[grafo->num_cidades]);
    printf("Cidade '%s' adicionada com ID %d\n", grafo->nomes[grafo->num_cidades], grafo->num_cidades);
    grafo->num_cidades++;
}

// Função para adicionar rota com validação completa
void adicionarRota(GrafoTSP *grafo) {
    if (grafo->num_cidades < 2) {
        printf("E necessario ter pelo menos 2 cidades cadastradas!\n");
        return;
    }
    
    int cidade1, cidade2;
    listarCidades(grafo);
    
    cidade1 = lerInteiro("\nDigite o ID da primeira cidade: ", 0, grafo->num_cidades - 1);
    cidade2 = lerInteiro("Digite o ID da segunda cidade: ", 0, grafo->num_cidades - 1);
    
    if (cidade1 == cidade2) {
        printf("A distancia de uma cidade para ela mesma e sempre 0!\n");
        return;
    }
    
    int distancia = lerInteiro("Digite a distancia (km): ", 1, INT_MAX);
    
    grafo->distancias[cidade1][cidade2] = distancia;
    grafo->distancias[cidade2][cidade1] = distancia;
    printf("Rota entre %s e %s atualizada para %d km\n", 
           grafo->nomes[cidade1], grafo->nomes[cidade2], distancia);
}

// Função para ver distância com validação
void verDistancia(GrafoTSP *grafo) {
    if (grafo->num_cidades < 2) {
        printf("E necessario ter pelo menos 2 cidades cadastradas!\n");
        return;
    }
    
    int cidade1, cidade2;
    listarCidades(grafo);
    
    cidade1 = lerInteiro("\nDigite o ID da primeira cidade: ", 0, grafo->num_cidades - 1);
    cidade2 = lerInteiro("Digite o ID da segunda cidade: ", 0, grafo->num_cidades - 1);
    
    if (cidade1 == cidade2) {
        printf("Distancia: 0 km (mesma cidade)\n");
        return;
    }
    
    if (grafo->distancias[cidade1][cidade2] == -1) {
        printf("Nao existe rota cadastrada entre %s e %s\n", 
               grafo->nomes[cidade1], grafo->nomes[cidade2]);
    } else {
        printf("Distancia entre %s e %s: %d km\n", 
               grafo->nomes[cidade1], grafo->nomes[cidade2], 
               grafo->distancias[cidade1][cidade2]);
    }
}

// Função para listar cidades
void listarCidades(GrafoTSP *grafo) {
    printf("\n=== CIDADES CADASTRADAS (%d/%d) ===\n", grafo->num_cidades, grafo->max_cidades);
    printf("ID\tNome\n");
    for (int i = 0; i < grafo->num_cidades; i++) {
        printf("%d\t%s\n", i, grafo->nomes[i]);
    }
}

// Menu principal com tratamento de erro
int exibirMenu() {
    int opcao;
    char input[50];
    
    while (1) {
        printf("\n=== MENU PRINCIPAL ===\n");
        printf("1. Adicionar cidade\n");
        printf("2. Adicionar/atualizar rota\n");
        printf("3. Ver distancia entre cidades\n");
        printf("4. Listar cidades\n");
        printf("5. Sair\n");
        printf("Escolha uma opcao: ");
        
        fgets(input, sizeof(input), stdin);
        if (sscanf(input, "%d", &opcao) == 1 && opcao >= 1 && opcao <= 5) {
            return opcao;
        }
        printf("Opcao invalida! Digite um numero entre 1 e 5.\n");
    }
}

int main() {
    GrafoTSP grafo;
    
    printf("SISTEMA DE GERENCIAMENTO DE ROTAS - CAIXEIRO VIAJANTE\n\n");
    
    // Configurar número máximo de cidades com validação
    int max_cidades = lerInteiro("Digite o numero maximo de cidades (2-100): ", 2, 100);
    inicializarGrafo(&grafo, max_cidades);
    
    int opcao;
    do {
        opcao = exibirMenu();
        
        switch(opcao) {
            case 1: adicionarCidade(&grafo); break;
            case 2: adicionarRota(&grafo); break;
            case 3: verDistancia(&grafo); break;
            case 4: listarCidades(&grafo); break;
            case 5: printf("Encerrando o programa...\n"); break;
        }
    } while(opcao != 5);
    
    liberarGrafo(&grafo);
    return 0;
}
